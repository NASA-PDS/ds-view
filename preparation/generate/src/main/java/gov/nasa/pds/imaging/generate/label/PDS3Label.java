//*************************************************************/
//Copyright (C) NASA/JPL  California Institute of Technology. */
//PDS Imaging Node                                            */
//All rights reserved.                                        */
//U.S. Government sponsorship is acknowledged.                */
//*************************************************************/
package gov.nasa.pds.imaging.generate.label;

import gov.nasa.pds.imaging.generate.TemplateException;
import gov.nasa.pds.imaging.generate.context.ContextUtil;
import gov.nasa.pds.imaging.generate.util.Debugger;

import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.w3c.dom.Document;
import org.w3c.dom.Node;

/**
 * Represents PDS3 Label object to provide the necessary functionality to
 *
 * @author jpadams
 * @author srlevoe
 *
 */
public class PDS3Label implements PDSObject {

    public static final String CONTEXT = "label";
    public ContextUtil ctxtUtil;

	private static final boolean debug = true;

    // Contains the DOM representation of
    // the PDS label as generated by the
    // PDSLabel2DOM parser
    private Document document;
    
    // Contains a flattened representation of
    // the PDS label. In this case, flattened
    // means everything has been normalized
    // to simple keyword=value pairs.
    private Map<String, Map> flatLabel;
    
    private List<String> pdsObjectTypes;
    private List<String> pdsObjectNames;
    
    private String filePath;
    private String configPath;

    /**
     * Empty Constructor, set everything later on
     */
    public PDS3Label() {
        this.filePath = null;
        this.flatLabel = new PDSTreeMap();
    }

    /**
     * Constructor
     *
     * @param filePath
     */
    public PDS3Label(final String filePath) {
        this.filePath = filePath;
        this.flatLabel = new PDSTreeMap();
        
        this.pdsObjectNames = new ArrayList<String>();
    }

    /**
     * Retrieves the value for the specified key
     *
     * @param key
     * @return value for key
     */
    @Override
    public final Object get(final String key) {
        final Object node = getNode(key.toUpperCase());
        Debugger.debug("\n\n++ Get " + key + " ----->");
        if (node == null) {
          return null;
        } else if (node instanceof ItemNode) {
        	Debugger.debug("++++ node(2) ------>\n" + ((ItemNode) node).toString());
            return ((ItemNode) node).toString();
        } else {
        	Debugger.debug("++ node(1) ------>\n" + node);
            return node;
        }
    }

    /**
     * Returns the variable to be used in the Velocity Template Engine to map to
     * this object.
     */
    @Override
    public final String getContext() {
        return CONTEXT;
    }

    @Override
    public final String getFilePath() {
        return this.filePath;
    }

    @Override
    public final List getList(final String key) throws TemplateException {
		return ((ItemNode) getNode(key)).getValues();
    }

    private final Object getNode(final String key) {
        // Handles call where . is embedded in key.
        // Mainly for IndexedGroup implementation.
        if (key.contains(".")) {
            final String[] links = key.split("\\.");
            // object->item
            // object->subobject->item
            if (links[0] == null) {
                return null;
            }
            LabelObject labelObj = (LabelObject) this.flatLabel.get(links[0]);
            if (labelObj == null) {
                return null;
            }
            Object obj = null;
            for (int i = 1; i < links.length; ++i) {
                obj = labelObj.get(links[i]);
                if (obj instanceof LabelObject) {
                    labelObj = (LabelObject) obj;
                }
            }
            return obj;
        }
        
        return this.flatLabel.get(key);
    }

    @Override
    public final List<Map<String, String>> getRecords(final String... keyword)
            throws TemplateException {

        this.ctxtUtil = new ContextUtil();
        
        for (int i = 0; i < keyword.length; i++) {
            this.ctxtUtil.addDictionaryElement(keyword[i].toUpperCase(),
                    getList(keyword[i].toUpperCase()));
        }
        return this.ctxtUtil.getDictionary();
    }

    @Override
    public final List<Map<String, String>> getRecordsWithIndices(
            final List<String> keys, final String... keyword)
            throws TemplateException {

        this.ctxtUtil = new ContextUtil();

        final int size = keys.size();
        if (keys.size() != keyword.length) {
            throw new TemplateException("getRecordsWithIndices method must contain"
                    + " same number of keys and keywords.");
        }

        for (int i = 0; i < size; i++) {
            this.ctxtUtil.addDictionaryElement(keys.get(i).toUpperCase(),
                    getList(keyword[i].toUpperCase()));
        }
        return this.ctxtUtil.getDictionary();
    }

    @Override
    public final String getUnits(final String key) {
        return ((ItemNode) getNode(key)).getUnits();
    }

    @Override
    public final void setParameters(PDSObject pdsObject, String confPath) {
    	this.configPath = confPath;
    	this.filePath = pdsObject.getFilePath();
    }

    @Override
    public void setMappings() {
    	Debugger.debug("+++++++++++++++++++++++++++\n"
    		+ "PDS3Label.setMapping()\n"
    		+ "document " + document
			+ "+++++++++++++++++++++++++++");
        try {
            final PDS3LabelReader reader = new PDS3LabelReader();

            // Look to see if we a document was already set
        	if (this.document == null) {
				Debugger.debug("+++++++++++++++++++++++++++\n"
					+ "PDS3Label.setMapping() document is null parseLabel");
	            this.document = reader.parseLabel(this.filePath);
			} else { // we already have the document supplied in the constructor
        		Debugger.debug("+++++++++++++++++++++++++++\n"
        			+ "PDS3Label.setMapping() document is GOOD using");	
        	}
        	
            // start of traversal of DOM
            final Node root = this.document.getDocumentElement();

            this.flatLabel = reader.traverseDOM(root);
            this.pdsObjectNames = reader.getPDSObjectNames();
        } catch (final FileNotFoundException fnfe) {
            // TODO - create a logger
            fnfe.printStackTrace();
        }
    }

    @Override
    public final String toString() {
        final StringBuffer strBuff = new StringBuffer();
        final Set<String> keys = this.flatLabel.keySet();
        for (final String key : keys) {
            // String key = (String) iter.next();
            strBuff.append(key + " = " + this.flatLabel.get(key) + "\n");
        }
        return strBuff.toString();
    }
    
    public final List<String> getPDSObjectNames() {
    	return this.pdsObjectNames;
    }

    @Deprecated
    private final void debug(String msg) {
    	if (this.debug) {
    		System.out.println(msg);
    	}
    }

}
